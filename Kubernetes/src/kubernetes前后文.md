#有了Docker，为什么还需要额外容器管理工具
https://baijiahao.baidu.com/s?id=1616891003670388822&wfr=spider&for=pc

   在容器的世界里，我们经常使用“编排”这个词语。编排 (orchestration)是一个没有严格定义的概念。 
   这个概念大概描述了自动配置、 协作和管理服务的过程。
   在 Docker的世界里，编排用来描述一组实践过程，这个过程会管理运行在多个Docker容器里的应用，而这些Docker容器有可能运行在多个宿主机上。 
   由于Docker是一个轻量级的容器管理平台，对编排的原生支持非常弱，因此整个社区围绕编排、开发和集成，建设了很多很棒的工具。 在现在的生态环境里，己经围绕Docker构建和集成了很多的工具。一些工具只是简单地将多个容器快捷地“连”在一起，使用简单的组合来构建应用程序栈。
   另外一些工具提供了在更大规模多个Docker宿主机上进行协作的能力，以及复杂的调度和执行能力。
   
#Docker三剑客

   Docker三剑客是Docker管理中最基本的三个工具。严格意义上，这三个工具并非都是编排工具。但是由于这三个工具非常出名，因此在这里统一介绍。
   
****一、Docker Machine****
：实现大规模主机环境的Docker的批量、自动化安装。

Docker Machine是Docker官方三剑客项目之一，负责使用Docker的第一步，在多种平台上快速安装Docker环境。它支持多种平台，让用户可以在很短时间内搭建一套Docker主机集群。

Machine项目主要由Go编写，用户可以在本地任意指定被Machine管理的Docker主机，并对其进行操作。Machine定位是“在本地或者云环境中创建Docker主机（Create Docker hosts on your computer，on cloud providers，and inside your own data center.）”。

其基本功能包括：

在指定节点上安装Docker引擎，配置其为Docker主机；

集中管理所有Docker主机。

**二、Docker Compose**

Compose项目是Docker官方的开源项目，定位是“定义和运行多个Docker容器的应用”，其前身是开源项目Fig，目前仍然兼容Fig格式的模板文件。 通过之前的文章，我们知道使用一个Dockerfile模板文件，可以让用户很方便地定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。

例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。

Compose恰好满足了这样的需求。它允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器为一个项目（project）。

**Compose中有两个重要的概念：**

**服务（service）：**
一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。

**项目（project）：**
由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义。

Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。

Compose项目由Python编写，实现上调用了Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。

**三、Docker Swarm**

**1、基础架构**

Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，也能够在主机上创建容器集群服务，那么这两者的区别在哪里呢？

Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。Docker Swarm提供Docker容器集群服务，是Docker官方对容器云生态进行支持的核心方案。使用它，用户可以将多个Docker主机封装为单个大型的虚拟Docker主机， 快速打造一套容器云平台。

**2、发现服务**

Docker集群管理需要使用服务发现（Service Discover）功能， Swarm支持以下几种方式：Docker Hub、本地文件、Etcd、Consul、Zookeeper和手动指定节点IP地址信息等。

除了手动指定外，这些方法原理上都是通过维护一套数据库机制来管理集群中注册节点的Docker Daemon的访问信息。

部署配置完毕后，可以看到整个Swarm集群就像一个虚拟的Docker主机一样正常工作。

由于Swarm实际上是通过agent调用了本地的Docker daemon来运行容器，当Swarm集群服务出现故障时，无法接受新的请求，但已经 运行起来的容器将不会受到影响。

**3、Swarm中的调度器**

调度是集群十分重要的功能，Swarm目前支持三种调度策略：spread、binpack和random。

在执行swarm manage命令启动管理服务的时候，可以通过--strategy参数指定调度策略，默认的是spread。

简单来说，这三种调度策略的优化目标如下：

spread：如果节点配置相同，选择一个正在运行的容器数量最少的那个节点，即尽量平摊容器到各个节点；

binpack：跟spread相反，尽可能地把所有的容器放在一台节点上运行，即尽量少用节点，避免容器碎片化。

random：直接随机分配，不考虑集群中节点的状态，方便进行测试使用。

**4、Swarm中的过滤器**

Swarm的调度器可以按照指定调度策略自动分配容器到节点，但有些时候希望能对这些分配加以干预。比如，让I/O敏感的容器分配到安装了SSD的节点上；让计算敏感的容器分配到CPU核数多的机器上；让网络敏感的容器分配到高带宽的机房；让某些容器尽量放同一个节点上，等等。

这可以通过过滤器（filter）来实现，目前支持五种过滤器：Constraint、Affinity、Port、Dependency、Health。

#~~Mesos~~
暂时没有必要

#Kubernetes(前身：Borg系统)
**一、概述**

Mesos作为一套成熟的开源项目，可以很好地被应用和集成到生产环境中。但它的定位集中在资源调度，往往需要结合应用框架或二次开发。


但Mesos在运行集群方面不如Kubernetes，它重点放在它强大的调度功能和它被插在各种各样的调度器的性能上。Mesos并不是为容器而生的，在容器流行之前就已经被开发出来，它的一些地方被修改来支持容器。


因此在对于容器和容器集群的生命周期管理层面，Mesos还是不够开箱即用，不够强大，也不够易用。由此我们就需要另外一个在容器界大名鼎鼎，呼风唤雨的容器集群管理工具：Kubernetes。


Kubernetes是Google团队发起并维护的开源容器集群管理系统，支持如Docker等容器技术。类似Docker Swarm，使用Kubernetes，用户可以轻松搭建和管理一个私有容器云。

**二、核心概念**

![img.png](img.png)
首先是集群组件，从架构上看，Kubernetes集群（Cluster）也采用了典型的“主-从”架构。一个集群主要由管理组件（Master）和工作节点（Node）组件构成。

另外，Kubernetes集群的主要任务始终围绕着应用的生命周期。 通过将不同资源进行不同层次的抽象，Kubernetes提供了灵活可靠的生命周期管理。资源的核心抽象主要包括：

容器组（Pod）：由位于同一节点上若干容器组成，彼此共享网络命名空间和存储卷（Volume）。Pod是Kubernetes中进行管理的最小资源单位，是最为基础的概念。跟容器类似，Pod是短暂的，随时可变的；

服务（Service）：若干（往往是同类型的）Pod形成的对外提供某个功能的抽象，不随Pod改变而变化，带有唯一固定的访问路径， 如IP地址或者域名。

复制控制器（Replication Controller）：负责启动Pod，并维护其健康运行的状态。是用户管理Pod的句柄。

部署（Deployment）：创建Pod，并可根据参数自动创建管理 Pod的复制控制器，并且支持升级。1.2.0版本引入提供比复制控制器更方便的操作；

横向Pod扩展器（Horizontal Pod Autoscaler，HPA）：类似云里面的自动扩展组，根据Pod的使用率（典型如CPU）自动调整一个部 署里面Pod的个数，保障服务可用性；

此外，还有一些管理资源相关的辅助概念，主要包括：

注解（Annotation）：键值对，可以存放大量任意数据，一般用来添加对资源对象的详细说明，可供其他工具处理。

标签（Label）：键值对，可以标记到资源对象上，用来对资源进行分类和筛选；

名字（Name）：用户提供给资源的别名，同类资源不能重名；

命名空间（Namespace）：这里是指资源的空间，避免不同租户的资源发生命名冲突，另外可以进行资源限额；

持久卷（PersistentVolume）：类似于Docker中数据卷的概念，就是一个数据目录，Pod对其有访问权限。

秘密数据（Secret）：存放敏感数据，例如用户认证的口令等；

选择器（Selector）：基于标签概念的一个正则表达式，可通过标签来筛选出一组资源；

Daemon集（DaemonSet）：确保节点上肯定运行某个Pod，一般用来采集日志和监控节点；

任务（Job）：确保给定数目的Pod正常退出（完成了任务）；

入口资源（Ingress Resource）：用来提供七层代理服务；

资源限额（Resource Quotas）：用来限制某个命名空间下对资源的使用，开始逐渐提供多租户支持；

安全上下文（Security Context）：应用到容器上的系统安全配置，包括uid、gid、capabilities、SELinux角色等；

服务账号（Service Accounts）：操作资源的用户账号。

**三、集群组件**

集群由使用Kubernetes组件管理的一组节点组成，这些节点提供了容器资源池供用户使用。主要包括管理（Master）组件和节点（Node）组件。

![img_1.png](img_1.png)
**Master组件**

![img_2.png](img_2.png)
顾名思义，Master组件提供所有与管理相关的操作，例如调度、监控、支持对资源的操作等。

Master会通过Node Controller来定期检查所管理的Node资源的健康状况，完成Node的生命周期管理。

**Node组件**

![img_3.png](img_3.png)
在Kubernetes中，Node是实际工作的计算实例（在1.1之前版本中名字叫做Minion）。节点可以是虚拟机或者物理机器，在创建 Kubernetes集群过程中，都要预装一些必要的软件来响应Master的管理。目前，Node的配置还只能通过人工手动进行，未来可以支持通过Master来自动配置。

Node节点有几个重要的属性：地址信息、阶段状态、资源容量、节点信息。

**地址信息包括：**

主机名（HostName）：节点所在系统的主机别名，基本不会用到；

外部地址（ExternalIP）：集群外部客户端可以通过该地址访问到的节点；

内部地址（InternalIP）：集群内可访问的地址，外部往往无法通过该地址访问节点。

**阶段状态包括：**

待定（Pending）：新创建节点，还未就绪状态，需要进一步的配置；

运行中（Running）：正常运行中的节点，可被分配Pod，会定期汇报运行状态消息；

终止（Terminated）：节点已经停止，处于不可用状态，判断条件为5分钟内未收到运行状态消息。

资源容量包括常见操作系统资源，如CPU、内存、最多存放的Pod个数等。

节点信息包括操作系统内核信息、Kubernetes版本信息、Docker 引擎版本信息等，会由kubelet定期汇报。


**四、资源抽象**

Kubernetes对集群中的资源进行了不同级别的抽象，每个资源都是一个REST对象，
通过API进行操作，通过JSON/YAML格式的模板文件进行定义。

**1、容器组（Pod）**

在Kubernetes中，并不直接操作容器，最小的管理单位是容器组 （Pod）。容器组由一个或多个容器组成，Kubernetes围绕容器组进行创建、调度、停止等生命周期管理。

同一个容器组中，各个容器共享命名空间（包括网络、IPC、文件系统等容器支持的命名空间）、cgroups限制和存储卷。

这意味着同一容器组中，各个应用可以很方便相互进行访问，比如通过localhost地址进行网络访问，通过信号量和共享内存进行进程间通信等，类似于经典场景中运行在同一个操作系统中的一组进程。

可以简单将一个Pod当作是一个抽象的“虚拟机”，里面运行若干个不同的进程（每个进程实际上就是一个容器）。

容器组内的若干容器往往是存在共同的应用目的，彼此关联十分紧密，例如一个Web应用和对应的日志采集应用或状态监控应用。如果单纯把这些相关的应用放一个容器里面，又会造成过度耦合，管理升级都不方便。

**容器组的经典应用场景包括：**

内容管理，文件和数据加载，缓存管理等；

日志处理，状态快照等；

监控代理，消息发布等；

代理机制，网桥、网卡等；

控制器，管理器，配置以及更新等。

可以说，容器组既保持了容器轻量解耦的特性，又提供了调度操作的便利性，在实践中提供了比单个容器更为灵活和更有意义的抽象。


**2、复制控制器和部署**

在Kubernetes看来，Pod资源是可以随时故障的，并不非要保证 Pod的运行，而是在发生失败后重新生成。Kubernetes通过复制控制器来实现这一功能。


用户申请容器组后，复制控制器（Replication Controller）将负责调度容器组到某个节点上，并保证它的给定份数（replica）正常运行。当实际运行Pod份数超过数目，则终止某些Pod；当不足，则创建新的Pod。一般建议， 即使Pod份数是1，也要使用复制控制器来创建，而不是直接创建Pod。


可以将复制控制器类比为进程的监管者（supervisor）的角色， 只不过它不光能保持Pod的持续运行，还能保持集群中给定类型Pod 同时运行的个数为指定值。


Pod是临时性的，可以随时被复制控制器创建或者销毁，这意味着要通过Pod自身的地址访问应用是不能保证一致性的。Kubernetes 通过服务的概念来解决这个问题。


从1.2.0版本开始，Kubernetes将正式引入部署（Deployment）机制来支持更灵活的Pod管理，从而用户无需直接跟复制控制器打交道了。


**3、横向Pod扩展器（Horizontal Pod Autoscaler）**

横向扩展器（HPA）在复制控制器和部署的基础上增加了自动反馈机制，通过定期查询Pod的资源利用率来调整Pod的数目，确保服务的可用性。


典型的一个场景是，定期（由--horizontal-pod-autoscaler-sync-period参数指定）通过Heapster组件来检查目标部署内Pod的平均CPU使用情况，当CPU使用率高出目标值，自动增加Pod数；反之降低。 内部机制是通过scale接口来操作资源。


**4、服务（Service）**

Kubernetes主要面向的对象是持续运行，并且无状态（stateless）。服务的提出主要是要解决Pod地址可变的问题。由于 Pod随时可能故障，并可能在其他节点上被重启起来，它的地址是不能保持固定的。因此，用一个服务来代表提供某一类功能（可以通过标签来筛选）的一些Pod，并分配不随Pod位置变化而改变的虚拟访问地址（Cluster IP）。这也符合微服务的理念。

比如网站的后端服务可能有多个Pod都运行了后端处理程序，它们可以组成一个服务。前端只需要通过服务的唯一虚拟地址来访问即可，而无需关心具体是访问到了哪个Pod。可见，服务跟负载均衡器实现的功能很相似。

组成一个服务的Pod可能属于不同复制控制器，但服务自身是不知道复制控制器的存在的。

同样，服务也是一个REST对象，用户可以通过模板来定义一个服务资源。

服务在创建后，会被自动分配一个集群地址（Cluster IP），这个地址并不绑定到任何接口，将作为访问服务的抽象地址。访问该地址会被映射到Pod的实际地址。实现上是通过kube-proxy进程。每个节点上都会运行一个kube-proxy进程，负责将到某个Service的访问给代 理或者均衡到具体的Pod上去。同时，会为每一个服务都创建环境变量，指向集群地址；或者在DNS中注册该服务的集群地址。

也许会有用户考虑使用DNS方式来替代服务的集群IP机制，这是完全可以的，Kubernetes也提供了基于skydns的插件支持。但是要处理好DNS查找的缓存过期时间问题。当某个Pod发生变化时，要让客户端本地的DNS缓存过期。

另外，服务支持进行不同类型的健康检查（通过容器spec中的livenessProbe或ReadinessProbe字段定义），目前包括三种类型：

通过HTTP获取资源是否成功；

在容器中执行指定命令，返回值是否为0；

打开给定socket端口是否成功。

探测的结果可能为成功、失败或未知。其中LivenessProbe反映的是容器自身状态，如果配置了重启策略，则失败状态会触发自动重启；而ReadinessProbe字段用来反映容器内的服务是否可用。

目前，Kubenetes支持在多种环境下的安装，包括本地主机（Fedora）、云服务（Google GAE、AWS等），但最快速体验Kubernetes的方式显然是在本地通过Docker容器的方式来快速启动相关进程。

**五.小结**

现有的容器方案并不能在跨多节点的环境里自己管理，调度以及部署容器，所以就需要Kubernetes。
